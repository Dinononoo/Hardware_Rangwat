// ESP32 + MPU6050 + PTFS Distance Sensor + BLE
// Combined sensor system for landslide monitoring
#include <Arduino.h>
#include <driver/gpio.h>
#include "Wire.h"
#include "I2Cdev.h"
#include "MPU6050.h"
#include "BLEDevice.h"
#include "BLEServer.h"
#include "BLEUtils.h"
#include "BLE2902.h"
#include "esp_bt.h"

// ================ Pin Configuration ================
#define SDA_PIN 21  // GPIO21 - I2C SDA
#define SCL_PIN 22  // GPIO22 - I2C SCL

// PTFS Distance Sensor Pins (5V system)
#define PTFS_RX_PIN 16  // GPIO16 (RX2) - ‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å PTFS TX
#define PTFS_TX_PIN 17  // GPIO17 (TX2) - ‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡πÑ‡∏õ PTFS RX (‡∏ú‡πà‡∏≤‡∏ô R-divider)
#define PTFS_PWR_PIN 2  // GPIO2 - Power Enable (‡∏à‡πà‡∏≤‡∏¢ HIGH ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏õ‡∏¥‡∏î PTFS)
#define PTFS_RST_PIN 4  // GPIO4 - Reset

// ================ BLE Configuration ================
#define SERVICE_UUID        "4fafc201-1fb5-459e-8fcc-c5c9c331914b"
#define CHARACTERISTIC_UUID "beb5483e-36e1-4688-b7f5-ea07361b26a8"
#define DEVICE_NAME         "ESP32_LANDSLIDE_MOCK"

// ================ Global Variables ================
MPU6050 mpu;
int16_t ax, ay, az, gx, gy, gz;

// ================ Advanced Precision System ================
// Professional-grade Complementary Filter for ¬±0.1¬∞ accuracy
float ax_filtered = 0, ay_filtered = 0, az_filtered = 0;
float gx_filtered = 0, gy_filtered = 0, gz_filtered = 0;

// Calibration variables - Enhanced for 3,000 samples
int16_t ax_offset = 0, ay_offset = 0, az_offset = 0;
int16_t gx_offset = 0, gy_offset = 0, gz_offset = 0;
bool calibrated = false;

// Professional Elevation System - ¬±0.1¬∞ accuracy
float elevation_raw = 0.0;           // Raw elevation from accelerometer
float elevation_gyro = 0.0;          // Elevation from gyroscope integration
float elevation_complementary = 0.0; // Final result from complementary filter
float elevation_previous = 0.0;      // Previous elevation for gyro integration

// Complementary Filter Parameters (Professional Grade)
const float ALPHA = 0.98;            // Gyroscope weight (high frequency)
const float BETA = 0.02;             // Accelerometer weight (low frequency)
const float GYRO_SENSITIVITY = 131.0; // LSB/¬∞/s for ¬±250¬∞/s range
const float DT = 0.01;               // 100 Hz sampling rate (10ms)

// Data Quality Assessment
float data_quality_score = 0.0;      // 0-100% quality score
float acceleration_magnitude = 0.0;  // Total acceleration magnitude
float gyro_magnitude = 0.0;          // Total gyro magnitude
bool high_quality_data = false;      // Quality threshold flag

// Sampling Rate Control
unsigned long last_sample_time = 0;
const unsigned long SAMPLE_INTERVAL = 10; // 100 Hz = 10ms interval

// ================ Professional Data Quality Assessment ================
float calculateDataQuality(float ax, float ay, float az, float gx, float gy, float gz) {
    // Calculate acceleration magnitude (should be ~1g when stationary)
    acceleration_magnitude = sqrt(ax*ax + ay*ay + az*az);
    
    // Calculate gyroscope magnitude (should be low when stationary)
    gyro_magnitude = sqrt(gx*gx + gy*gy + gz*gz);
    
    // Quality assessment based on multiple factors
    float quality = 100.0;
    
    // Check acceleration magnitude (should be close to 1g)
    float accel_error = abs(acceleration_magnitude - 1.0);
    if (accel_error > 0.1) {
        quality -= accel_error * 200; // Penalty for acceleration error
    }
    
    // Check gyroscope magnitude (should be low when stationary)
    if (gyro_magnitude > 50.0) { // High rotation
        quality -= (gyro_magnitude - 50.0) * 0.5; // Penalty for high rotation
    }
    
    // Check for reasonable values
    if (acceleration_magnitude < 0.5 || acceleration_magnitude > 2.0) {
        quality = 0.0; // Invalid data
    }
    
    // Ensure quality is between 0-100%
    if (quality < 0.0) quality = 0.0;
    if (quality > 100.0) quality = 100.0;
    
    return quality;
}

// ================ Professional Complementary Filter ================
float applyComplementaryFilter(float accel_angle, float gyro_rate, float dt) {
    // Gyroscope integration (high frequency, short-term accuracy)
    elevation_gyro = elevation_previous + gyro_rate * dt;
    
    // Complementary filter: combine accelerometer (low freq) + gyroscope (high freq)
    elevation_complementary = ALPHA * elevation_gyro + BETA * accel_angle;
    
    // Update previous value for next iteration
    elevation_previous = elevation_complementary;
    
    return elevation_complementary;
}

// BLE variables
BLEServer* pServer = NULL;
BLECharacteristic* pCharacteristic = NULL;
bool deviceConnected = false;
bool oldDeviceConnected = false;

// Data variables
float distance = 0.0;  // ‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡∏à‡∏£‡∏¥‡∏á‡∏à‡∏≤‡∏Å PTFS sensor
int currentMode = 1;
unsigned long lastSendTime = 0;
const long sendInterval = 1000;  // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å 500ms ‡πÄ‡∏õ‡πá‡∏ô 1000ms ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏™‡∏ñ‡∏µ‡∏¢‡∏£

// ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î
bool mpu6050Healthy = false;
bool ptfsHealthy = false;
bool bleHealthy = false;
unsigned long lastMPU6050Check = 0;
unsigned long lastPTFSCheck = 0;
unsigned long lastBLECheck = 0;
const unsigned long healthCheckInterval = 5000; // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ó‡∏∏‡∏Å 5 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
int errorCount = 0;
const int maxErrorCount = 10; // ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î‡∏Å‡πà‡∏≠‡∏ô‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï

// PTFS variables
uint8_t ptfsBuffer[200];
int ptfsBufferIndex = 0;
bool ptfsMeasurementActive = false;
bool loopbackDetected = false;  // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö loopback
unsigned long lastPTFSCommand = 0;
unsigned long lastPTFSAnalysis = 0;
unsigned long lastPTFSDisplayTime = 0;
const unsigned long ptfsCommandInterval = 2000;  // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏õ‡πá‡∏ô 2 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏™‡∏ñ‡∏µ‡∏¢‡∏£
const unsigned long ptfsAnalysisInterval = 1000;  // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏õ‡πá‡∏ô 1 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏™‡∏ñ‡∏µ‡∏¢‡∏£

// Distance filter (‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡∏ô‡∏≤‡∏î‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏™‡∏ñ‡∏µ‡∏¢‡∏£)
#define DISTANCE_FILTER_SIZE 30  // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å 20 ‡πÄ‡∏õ‡πá‡∏ô 30
float distanceHistory[DISTANCE_FILTER_SIZE] = {0};
int distanceFilterIndex = 0;
bool distanceFilterFull = false;

// ================ BLE Callbacks ================
class MyServerCallbacks: public BLEServerCallbacks {
    void onConnect(BLEServer* pServer) {
        deviceConnected = true;
        Serial.println("üîµ ‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠!");
    };

    void onDisconnect(BLEServer* pServer) {
        deviceConnected = false;
        Serial.println("üî¥ ‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡∏ï‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠!");
    }
};

class MyCharacteristicCallbacks: public BLECharacteristicCallbacks {
    void onWrite(BLECharacteristic *pCharacteristic) {
        uint8_t* data = pCharacteristic->getData();
        size_t len = pCharacteristic->getLength();
        String value = "";
        for (int i = 0; i < len; i++) {
            value += (char)data[i];
        }
        Serial.print("‡∏£‡∏±‡∏ö‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á: ");
        Serial.println(value);

        if (value == "MODE1") currentMode = 1;
        else if (value == "MODE2") currentMode = 2;
    }
};

// ================ System Health Monitoring ================
// ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏£‡∏∞‡∏ö‡∏ö
bool checkMPU6050Health() {
    if (mpu.testConnection()) {
        mpu6050Healthy = true;
        return true;
    } else {
        mpu6050Healthy = false;
        Serial.println("‚ùå MPU6050 Health Check Failed!");
        return false;
    }
}

bool checkPTFSHealth() {
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏ï‡∏≠‡∏ö‡∏™‡∏ô‡∏≠‡∏á‡∏à‡∏≤‡∏Å PTFS ‡πÉ‡∏ô‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î
    if (millis() - lastPTFSAnalysis < 10000) { // 10 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
        ptfsHealthy = true;
        return true;
    } else {
        ptfsHealthy = false;
        Serial.println("‚ö†Ô∏è PTFS Health Check Failed - No Response!");
        return false;
    }
}

bool checkBLEHealth() {
    if (pServer && pCharacteristic) {
        bleHealthy = true;
        return true;
    } else {
        bleHealthy = false;
        Serial.println("‚ùå BLE Health Check Failed!");
        return false;
    }
}

void performHealthCheck() {
    static unsigned long lastHealthCheck = 0;
    
    if (millis() - lastHealthCheck >= healthCheckInterval) {
        bool mpuOK = checkMPU6050Health();
        bool ptfsOK = checkPTFSHealth();
        bool bleOK = checkBLEHealth();
        
        // ‡∏ô‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î
        if (!mpuOK || !ptfsOK || !bleOK) {
            errorCount++;
            Serial.printf("‚ö†Ô∏è Health Check Failed! Error Count: %d/%d\n", errorCount, maxErrorCount);
            
            // ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏£‡∏∞‡∏ö‡∏ö‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏°‡∏≤‡∏Å‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ
            if (errorCount >= maxErrorCount) {
                Serial.println("üîÑ Too Many Errors - Restarting System...");
                ESP.restart();
            }
        } else {
            errorCount = 0; // ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏ï‡∏±‡∏ß‡∏ô‡∏±‡∏ö‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏£‡∏∞‡∏ö‡∏ö‡∏õ‡∏Å‡∏ï‡∏¥
        }
        
        // ‡πÅ‡∏™‡∏î‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏´‡∏ô‡πà‡∏ß‡∏¢‡∏Ñ‡∏ß‡∏≤‡∏°‡∏à‡∏≥
        Serial.printf("üíæ Free Heap: %d bytes\n", ESP.getFreeHeap());
        if (ESP.getFreeHeap() < 10000) {
            Serial.println("‚ö†Ô∏è Low Memory Warning!");
        }
        
        lastHealthCheck = millis();
    }
}

// ================ PTFS Functions ================
void sendPTFSCommand(uint8_t* cmd, uint8_t length) {
    for (int i = 0; i < length; i++) {
        Serial2.write(cmd[i]);
        delayMicroseconds(100);
    }
        Serial2.flush();
}

void startPTFSMeasurement() {
    if (!ptfsMeasurementActive) {
        return;
    }
    
    // ‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á PTFS Protocol ‡πÅ‡∏ö‡∏ö‡πÄ‡∏î‡∏µ‡∏¢‡∏ß (‡πÑ‡∏°‡πà‡∏™‡∏±‡∏ö‡∏™‡∏ô)
    uint8_t startCmd[] = {
        0xFA,           // MsgType
        0x01,           // MsgCode (Start)
        0x00,           // BrdId (broadcast)
        0x04,           // PayLoadLen
        0x01, 0x00,     // MeaType (start measurement)
        0x00, 0x00,     // MeaTimes (unlimited)
        0x00            // CRC
    };
    
    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì CRC
    uint8_t crc = 0;
    for (int i = 0; i < 8; i++) {
        crc += startCmd[i];
    }
    startCmd[8] = crc & 0xFF;
    
    // ‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á
    sendPTFSCommand(startCmd, 9);
    
    // ‚úÖ ‡∏õ‡∏¥‡∏î debug
    // Serial.println("üì° Sent PTFS command");
}

void addDistanceToFilter(float value) {
    distanceHistory[distanceFilterIndex] = value;
    distanceFilterIndex = (distanceFilterIndex + 1) % DISTANCE_FILTER_SIZE;
    
    if (!distanceFilterFull && distanceFilterIndex == 0) {
        distanceFilterFull = true;
    }
}

// ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏•‡πâ‡∏≤‡∏á Filter
void clearDistanceFilter() {
    for (int i = 0; i < DISTANCE_FILTER_SIZE; i++) {
        distanceHistory[i] = 0.0;
    }
    distanceFilterIndex = 0;
    distanceFilterFull = false;
}

float getFilteredDistance() {
    if (!distanceFilterFull && distanceFilterIndex == 0) return 0.0;
    
    float sum = 0;
    int count = distanceFilterFull ? DISTANCE_FILTER_SIZE : distanceFilterIndex;
    
    for (int i = 0; i < count; i++) {
        sum += distanceHistory[i];
    }
    
    return (count > 0) ? sum / count : 0.0;
}

// **‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡πà‡∏≤‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡πÉ‡∏ô array** (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô distance project)
void addDistance(uint16_t* distances, int* counts, int* foundCount, uint16_t value, int maxSize) {
    // ‡∏´‡∏≤‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏Ñ‡πà‡∏≤‡∏ô‡∏µ‡πâ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    for (int i = 0; i < *foundCount; i++) {
        if (distances[i] == value) {
            counts[i]++;
            return;
        }
    }
    
    // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ ‡πÅ‡∏•‡∏∞‡∏¢‡∏±‡∏á‡∏°‡∏µ‡∏ó‡∏µ‡πà‡∏ß‡πà‡∏≤‡∏á ‡πÉ‡∏´‡πâ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÉ‡∏´‡∏°‡πà
    if (*foundCount < maxSize) {
        distances[*foundCount] = value;
        counts[*foundCount] = 1;
        (*foundCount)++;
    }
}

void processPTFSData(uint8_t* data, uint8_t length) {
    // ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô loopback data ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà (‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡πÉ‡∏´‡πâ‡πÄ‡∏™‡∏ñ‡∏µ‡∏¢‡∏£‡∏Ç‡∏∂‡πâ‡∏ô)
    if (length > 10 && data[0] == 0xFA) {
        return; // ‡∏Å‡∏£‡∏≠‡∏á‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏°‡∏≤‡∏Å‡πÅ‡∏•‡πâ‡∏ß
    }

    // ‡∏•‡∏≠‡∏á‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡πÅ‡∏°‡πâ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ô‡πâ‡∏≠‡∏¢
    if (length < 3) return; // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å 1 ‡πÄ‡∏õ‡πá‡∏ô 3
    
    // ‚úÖ ‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Raw ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏≠‡∏≤‡∏î
    // static unsigned long lastRawDisplay = 0;
    // if (millis() - lastRawDisplay >= 2000) { // ‡πÅ‡∏™‡∏î‡∏á‡∏ó‡∏∏‡∏Å 2 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
    //     Serial.print("üì° Raw PTFS Data: ");
    //     for (int i = 0; i < (length < 20 ? length : 20); i++) { // ‡πÅ‡∏™‡∏î‡∏á‡πÅ‡∏Ñ‡πà 20 bytes ‡πÅ‡∏£‡∏Å
    //         Serial.printf("0x%02X ", data[i]);
    //     }
    //     if (length > 20) Serial.print("...");
    //     Serial.printf(" (Length: %d)\n", length);
    //     
    //     // ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Raw
    //     if (length >= 9 && data[0] == 0xFB && data[1] == 0x03) {
    //         uint8_t dataValid = data[4];
    //         uint16_t rawDistance = data[6] | (data[7] << 8);
    //         Serial.printf("   üìä Analysis: dataValid=%d, rawDistance=%d dm (%.1fm)\n", 
    //                      dataValid, rawDistance, rawDistance/10.0);
    //     }
    //     
    //     lastRawDisplay = millis();
    // }
    
    // **‡πÉ‡∏ä‡πâ Map/Counter ‡πÄ‡∏•‡πá‡∏Å‡πÜ ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á** (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô distance project)
    const int maxDistances = 20;
    uint16_t distances[maxDistances];
    int distanceCount[maxDistances];
    int foundDistances = 0;
    
    // üéØ **PTFS Official Protocol - Table 5-2 Measurement Report**
    // Format: 0xFB 0x03 BrdId 0x04 DataValidInd Distance_L Distance_H CRC
    
    // Pattern 1: PTFS Standard Protocol (‡∏ï‡∏≤‡∏°‡∏Ñ‡∏π‡πà‡∏°‡∏∑‡∏≠)
    for (int i = 0; i <= length - 8; i++) {
        if (data[i] == 0xFB && data[i+1] == 0x03 && data[i+3] == 0x04) {
            uint8_t dataValid = data[i+4];  // DataValidInd (1=valid, 0=invalid)
            
            if (dataValid == 1) {  // ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á
                // Distance in Little Endian format (dm)
                uint16_t dm_value = data[i+6] | (data[i+7] << 8);
                
                // Serial.printf("üîç PTFS Protocol: dm_value=%d, dataValid=%d\n", dm_value, dataValid);
                
                // ‚úÖ ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á
                if (dm_value >= 30 && dm_value <= 10000) {  // 3m-1000m
                    addDistance(distances, distanceCount, &foundDistances, dm_value, maxDistances);
                } else if (dm_value == 0) {
                    // ‚úÖ ‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á 0m = ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡πÉ‡∏ô‡∏£‡∏∞‡∏¢‡∏∞‡∏ß‡∏±‡∏î
                    // Serial.println("üìè PTFS: No object detected (0m)");
                } else {
                    // Serial.printf("‚ö†Ô∏è  PTFS: Invalid distance value: %d dm\n", dm_value);
                }
            } else {
                // Serial.printf("‚ö†Ô∏è  PTFS: Invalid data (dataValid=%d)\n", dataValid);
            }
        }
    }
    
    // Pattern New: TOF Protocol (0x5A responses) - ‚úÖ ‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÄ‡∏°‡∏∑‡πà‡∏≠ dataValid=0
    // ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• PTFS Protocol ‡∏ó‡∏µ‡πà dataValid=0 ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    bool hasInvalidPTFSData = false;
    for (int i = 0; i <= length - 8; i++) {
        if (data[i] == 0xFB && data[i+1] == 0x03 && data[i+3] == 0x04) {
            uint8_t dataValid = data[i+4];
            if (dataValid == 0) {
                hasInvalidPTFSData = true;
                // Serial.println("üö´ PTFS: dataValid=0 detected - skipping TOF Protocol");
                break;
            }
        }
    }
    
    // ‚úÖ ‡πÉ‡∏ä‡πâ TOF Protocol ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• PTFS ‡∏ó‡∏µ‡πà dataValid=0
    if (!hasInvalidPTFSData) {
        for (int i = 0; i <= length - 6; i++) {
            if (data[i] == 0x5A && i + 5 < length) {
                uint16_t dm_value = data[i+4] | (data[i+5] << 8);
                // Serial.printf("üîç TOF Protocol: dm_value=%d\n", dm_value);
                if (dm_value >= 30 && dm_value <= 10000) {
                    addDistance(distances, distanceCount, &foundDistances, dm_value, maxDistances);
                }
            }
        }
    }
    
    // Pattern 2: 9600 bps Format (80 0C 08 XX pattern) - ‚úÖ ‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÄ‡∏°‡∏∑‡πà‡∏≠ dataValid=0
    // ‚úÖ ‡πÉ‡∏ä‡πâ 9600 bps Format ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• PTFS ‡∏ó‡∏µ‡πà dataValid=0
    if (!hasInvalidPTFSData) {
        for (int i = 0; i < length - 3; i++) {
            if (data[i] == 0x80 && data[i+1] == 0x0C && data[i+2] == 0x08) {
                uint16_t dm_value = data[i+3];  // ‡∏Ñ‡πà‡∏≤‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡πÉ‡∏ô dm
                // Serial.printf("üîç 9600bps Format: dm_value=%d\n", dm_value);
                if (dm_value >= 30 && dm_value <= 1000) {
                    addDistance(distances, distanceCount, &foundDistances, dm_value, maxDistances);
                }
            }
        }
    }
    
    // Pattern 3: Smart 16-bit search (‡∏´‡∏•‡∏µ‡∏Å‡πÄ‡∏•‡∏µ‡πà‡∏¢‡∏á garbage) - ‚úÖ ‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÄ‡∏°‡∏∑‡πà‡∏≠ dataValid=0
    if (foundDistances == 0) {
        // ‚úÖ ‡πÉ‡∏ä‡πâ 16-bit search ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• PTFS ‡∏ó‡∏µ‡πà dataValid=0
        if (!hasInvalidPTFSData) {
            for (int i = 0; i < length - 1; i++) {
                // ‡∏Ç‡πâ‡∏≤‡∏° garbage bytes
                if (data[i] == 0xFE || data[i] == 0xFF || data[i+1] == 0xFE || data[i+1] == 0xFF) {
                    continue;
                }
                
                // Little Endian 16-bit
                uint16_t dm_value = data[i] | (data[i+1] << 8);
                if (dm_value >= 30 && dm_value <= 1000) {
                    // Serial.printf("üîç 16-bit LE: dm_value=%d\n", dm_value);
                    addDistance(distances, distanceCount, &foundDistances, dm_value, maxDistances);
                }
                
                // Big Endian 16-bit  
                dm_value = (data[i] << 8) | data[i+1];
                if (dm_value >= 30 && dm_value <= 1000) {
                    // Serial.printf("üîç 16-bit BE: dm_value=%d\n", dm_value);
                    addDistance(distances, distanceCount, &foundDistances, dm_value, maxDistances);
                }
            }
        }
    }
    
    // Pattern 4: Single byte reasonable values - ‚úÖ ‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÄ‡∏°‡∏∑‡πà‡∏≠ dataValid=0
    if (foundDistances == 0) {
        // ‚úÖ ‡πÉ‡∏ä‡πâ single byte search ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• PTFS ‡∏ó‡∏µ‡πà dataValid=0
        if (!hasInvalidPTFSData) {
            for (int i = 0; i < length; i++) {
                if (data[i] >= 10 && data[i] <= 200 && data[i] != 0xFE && data[i] != 0xFF && data[i] != 0x00) {
                    // Serial.printf("üîç Single byte: dm_value=%d\n", data[i]);
                    addDistance(distances, distanceCount, &foundDistances, data[i], maxDistances);
                }
            }
        }
    }
    
    // **‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤‡πÅ‡∏£‡∏Å‡∏ó‡∏µ‡πà‡∏´‡∏≤‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢ (‡πÄ‡∏£‡πá‡∏ß‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î)** ‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô distance project
    int bestDm = 0;
    
    // ‚úÖ ‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏û‡∏ö‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
    // Serial.printf("üîç Found %d different distances:\n", foundDistances);
    // for (int i = 0; i < foundDistances; i++) {
    //     Serial.printf("   Distance[%d]: %d dm (count: %d)\n", i, distances[i], distanceCount[i]);
    // }
    
    // ‡∏´‡∏≤‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏µ‡πà‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î ‡πÅ‡∏•‡∏∞‡∏°‡∏µ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ô‡πà‡∏≤‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏ñ‡∏∑‡∏≠ (‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏Ç‡πâ‡∏°‡∏á‡∏ß‡∏î)
    int bestCount = 0;
    for (int i = 0; i < foundDistances; i++) {
        if (distanceCount[i] > bestCount && distanceCount[i] >= 5) { // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å 3 ‡πÄ‡∏õ‡πá‡∏ô 5
            bestCount = distanceCount[i];
            bestDm = distances[i];
        }
    }
    
    // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏ñ‡∏∑‡∏≠‡πÑ‡∏î‡πâ ‡πÉ‡∏´‡πâ‡∏´‡∏≤‡∏Ñ‡πà‡∏≤‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢‡∏Ç‡∏≠‡∏á‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡πÉ‡∏Å‡∏•‡πâ‡πÄ‡∏Ñ‡∏µ‡∏¢‡∏á‡∏Å‡∏±‡∏ô
    if (bestDm == 0 && foundDistances > 0) {
        uint32_t sum = 0;
        int count = 0;
        uint16_t refValue = distances[0];
        
        // ‡∏£‡∏ß‡∏°‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡πÉ‡∏Å‡∏•‡πâ‡πÄ‡∏Ñ‡∏µ‡∏¢‡∏á‡∏Å‡∏±‡∏ô (‡∏ï‡πà‡∏≤‡∏á‡∏Å‡∏±‡∏ô‡πÑ‡∏°‡πà‡πÄ‡∏Å‡∏¥‡∏ô 20dm = 2m)
        for (int i = 0; i < foundDistances; i++) {
            if (abs((int)distances[i] - (int)refValue) <= 20) {
                sum += distances[i];
                count++;
            }
        }
        
        if (count >= 2) {
            bestDm = sum / count; // ‡∏Ñ‡πà‡∏≤‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢‡∏ó‡∏µ‡πà‡πÄ‡∏™‡∏ñ‡∏µ‡∏¢‡∏£
        } else {
            bestDm = distances[0]; // ‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤‡πÅ‡∏£‡∏Å
        }
    }
    
    // ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏ï‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ (‡∏û‡∏£‡πâ‡∏≠‡∏° Moving Average Filter) ‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô distance project
    if (bestDm > 0) {
        // ‚úÖ ‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• debug
        // Serial.printf("üîç PTFS Debug: bestDm=%d, foundDistances=%d\n", bestDm, foundDistances);
        
        // ‚úÖ ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á
        if (bestDm < 30) { // ‡∏ô‡πâ‡∏≠‡∏¢‡∏Å‡∏ß‡πà‡∏≤ 3.0m
            // Serial.printf("‚ö†Ô∏è  ‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ (%d dm = %.1fm) - ‡∏ï‡∏±‡πâ‡∏á‡πÄ‡∏õ‡πá‡∏ô 0m\n", bestDm, bestDm/10.0);
            // ‚úÖ ‡∏•‡πâ‡∏≤‡∏á Filter ‡πÅ‡∏•‡∏∞‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡πÄ‡∏õ‡πá‡∏ô 0 ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏ô‡πâ‡∏≠‡∏¢‡∏Å‡∏ß‡πà‡∏≤ 3m
            clearDistanceFilter();
            distance = 0.0;
            
            // ‚úÖ ‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏ó‡∏±‡∏ô‡∏ó‡∏µ
            // if (millis() - lastPTFSDisplayTime >= 1000) {
            //     Serial.printf("üìè PTFS Distance: 0.0m (Raw: %.1fm - Too Close)\n", bestDm/10.0);
            //     lastPTFSDisplayTime = millis();
            // }
        } else {
            // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡πà‡∏≤‡πÉ‡∏ô Moving Average Filter
            float meters = bestDm / 10.0;
            
            // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏™‡∏°‡πÄ‡∏´‡∏ï‡∏∏‡∏™‡∏°‡∏ú‡∏•
            if (meters > 0 && meters < 1000) {
                addDistanceToFilter(meters);
                distance = getFilteredDistance();
                
                // ‚úÖ ‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏ó‡∏∏‡∏Å 1 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
                // if (millis() - lastPTFSDisplayTime >= 1000) {
                //     Serial.printf("üìè PTFS Distance: %.1fm (Raw: %.1fm)\n", distance, meters);
                //     lastPTFSDisplayTime = millis();
                // }
            } else {
                // Serial.printf("‚ö†Ô∏è  ‡∏Ñ‡πà‡∏≤‡πÑ‡∏°‡πà‡∏™‡∏°‡πÄ‡∏´‡∏ï‡∏∏‡∏™‡∏°‡∏ú‡∏•: %.1fm - ‡∏ï‡∏±‡πâ‡∏á‡πÄ‡∏õ‡πá‡∏ô 0m\n", meters);
                // ‚úÖ ‡∏•‡πâ‡∏≤‡∏á Filter ‡πÅ‡∏•‡∏∞‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡πÄ‡∏õ‡πá‡∏ô 0 ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡∏™‡∏°‡πÄ‡∏´‡∏ï‡∏∏‡∏™‡∏°‡∏ú‡∏•
                clearDistanceFilter();
                distance = 0.0;
            }
        }
    } else {
        // ‚úÖ ‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á - ‡∏ï‡∏±‡πâ‡∏á‡πÄ‡∏õ‡πá‡∏ô 0m
        // Serial.println("üìè PTFS: No valid distance data - setting to 0m");
        clearDistanceFilter();
        distance = 0.0;
    }
}

void processPTFSStream() {
    // ‚úÖ ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏´‡∏ô‡πà‡∏ß‡∏¢‡∏Ñ‡∏ß‡∏≤‡∏°‡∏à‡∏≥
    static unsigned long lastBufferCleanup = 0;
    
    // ‡∏•‡πâ‡∏≤‡∏á‡∏ö‡∏±‡∏ü‡πÄ‡∏ü‡∏≠‡∏£‡πå‡πÄ‡∏õ‡πá‡∏ô‡∏£‡∏∞‡∏¢‡∏∞‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏´‡∏ô‡πà‡∏ß‡∏¢‡∏Ñ‡∏ß‡∏≤‡∏°‡∏à‡∏≥‡πÄ‡∏ï‡πá‡∏°
    if (millis() - lastBufferCleanup >= 30000) { // ‡∏ó‡∏∏‡∏Å 30 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
        ptfsBufferIndex = 0;
        lastBufferCleanup = millis();
    }
    
    while (Serial2.available()) {
        uint8_t newByte = Serial2.read();
        
        // ‡∏•‡∏î‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö loopback ‡∏ó‡∏µ‡πà‡πÄ‡∏Ç‡πâ‡∏°‡∏á‡∏ß‡∏î‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ
        if (newByte == 0xFA && ptfsBufferIndex > 15) {
            // ‡∏•‡πâ‡∏≤‡∏á‡∏ö‡∏±‡∏ü‡πÄ‡∏ü‡∏≠‡∏£‡πå‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏°‡∏≤‡∏Å‡πÅ‡∏•‡πâ‡∏ß
            ptfsBufferIndex = 0;
            continue;
        }
        
        ptfsBuffer[ptfsBufferIndex++] = newByte;
        
        // ‚úÖ ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏ö‡∏±‡∏ü‡πÄ‡∏ü‡∏≠‡∏£‡πå
        if (ptfsBufferIndex >= 200) {
            ptfsBufferIndex = 0; // ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏ö‡∏±‡∏ü‡πÄ‡∏ü‡∏≠‡∏£‡πå‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏ï‡πá‡∏°
            Serial.println("‚ö†Ô∏è PTFS Buffer Overflow - Reset!");
        }
    }
    
    // ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ä‡πâ‡∏≤‡∏•‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏™‡∏ñ‡∏µ‡∏¢‡∏£
    if (ptfsBufferIndex >= 8) { // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å 2 ‡πÄ‡∏õ‡πá‡∏ô 8
        processPTFSData(ptfsBuffer, ptfsBufferIndex);
        lastPTFSAnalysis = millis();
        ptfsBufferIndex = 0;
    }
}

// ================ MPU6050 Functions ================
// Advanced Pitch Calculation using Accelerometer + Gyroscope
void initializeAdvancedPitch() {
    Serial.println("üîß Initializing Advanced Pitch Calculation...");
    Serial.println("   üìê Using Accelerometer + Gyroscope for accurate pitch");
    Serial.println("   üéØ Range: -90¬∞ to +90¬∞ (Pitch/Elevation)");
    Serial.println("   ‚úÖ Roll Independent - ‡πÑ‡∏°‡πà‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏≠‡∏µ‡∏¢‡∏á‡∏ã‡πâ‡∏≤‡∏¢‡∏Ç‡∏ß‡∏≤");
}

void calibrateMPU6050() {
    Serial.println("üîß Starting PROFESSIONAL MPU6050 calibration for ¬±0.1¬∞ accuracy...");
    Serial.println("   üìê Keep sensor FLAT and STILL for 30 seconds...");
    Serial.println("   üéØ This will set Elevation = 0¬∞ when sensor is level (‡πÅ‡∏ô‡∏ß‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏™‡∏≤‡∏¢‡∏ï‡∏≤)");
    Serial.println("   ‚ö†Ô∏è  Make sure sensor is perfectly horizontal (‡∏Ç‡∏ô‡∏≤‡∏ô‡∏Å‡∏±‡∏ö‡∏û‡∏∑‡πâ‡∏ô‡πÇ‡∏•‡∏Å)!");
    Serial.println("   üéØ Enhanced calibration: 3,000 samples for maximum precision");
    
    delay(3000);
    
    long ax_sum = 0, ay_sum = 0, az_sum = 0;
    long gx_sum = 0, gy_sum = 0, gz_sum = 0;
    const int samples = 3000; // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏õ‡πá‡∏ô 3,000 samples ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏°‡πà‡∏ô‡∏¢‡∏≥‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î
    
    Serial.println("   üîÑ Professional Calibrating... (30 seconds)");
    
    for (int i = 0; i < samples; i++) {
        mpu.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);
        ax_sum += ax;
        ay_sum += ay;
        az_sum += az;
        gx_sum += gx;
        gy_sum += gy;
        gz_sum += gz;
        
        // ‡πÅ‡∏™‡∏î‡∏á‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Ñ‡∏∑‡∏ö‡∏´‡∏ô‡πâ‡∏≤
        if (i % 300 == 0) {
            Serial.printf("   üìä Progress: %d/%d samples (%.1f%%)\n", i, samples, (float)i/samples*100);
        }
        delay(10);
    }
    
    // ‚úÖ Professional calibration for both accelerometer and gyroscope
    ax_offset = ax_sum / samples;
    ay_offset = ay_sum / samples;
    az_offset = az_sum / samples - 16384; // Z-axis = 0 ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏ß‡∏≤‡∏á‡∏£‡∏≤‡∏ö
    
    // Gyroscope calibration (should be 0 when stationary)
    gx_offset = gx_sum / samples;
    gy_offset = gy_sum / samples;
    gz_offset = gz_sum / samples;
    
    // ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≤‡∏•‡∏¥‡πÄ‡∏ö‡∏£‡∏ï‡πÅ‡∏ö‡∏ö‡∏°‡∏∑‡∏≠‡∏≠‡∏≤‡∏ä‡∏µ‡∏û
    Serial.printf("   üìä Accelerometer Offsets: Ax=%d, Ay=%d, Az=%d\n", ax_offset, ay_offset, az_offset);
    Serial.printf("   üìä Gyroscope Offsets: Gx=%d, Gy=%d, Gz=%d\n", gx_offset, gy_offset, gz_offset);
    
    // ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≤‡∏•‡∏¥‡πÄ‡∏ö‡∏£‡∏ï
    float accel_magnitude = sqrt((ax_offset/16384.0)*(ax_offset/16384.0) + 
                                (ay_offset/16384.0)*(ay_offset/16384.0) + 
                                ((az_offset+16384)/16384.0)*((az_offset+16384)/16384.0));
    float gyro_magnitude = sqrt((gx_offset/131.0)*(gx_offset/131.0) + 
                               (gy_offset/131.0)*(gy_offset/131.0) + 
                               (gz_offset/131.0)*(gz_offset/131.0));
    
    Serial.printf("   üìä Calibration Quality: Accel=%.3f g, Gyro=%.1f¬∞/s\n", accel_magnitude, gyro_magnitude);
    
    // ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ Z-axis ‡πÉ‡∏Å‡∏•‡πâ 16384 ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà (‡∏Ñ‡∏ß‡∏£‡πÄ‡∏õ‡πá‡∏ô 1g)
    if (abs(az_offset) > 1000) {
        Serial.println("   ‚ö†Ô∏è Z-axis offset seems wrong, adjusting...");
        az_offset = az_sum / samples; // ‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤‡πÄ‡∏î‡∏¥‡∏°
    }
    
    calibrated = true;
    Serial.println("‚úÖ PROFESSIONAL MPU6050 Calibration Complete!");
    Serial.printf("   üìä Enhanced Offsets: Ax=%d, Ay=%d, Az=%d\n", ax_offset, ay_offset, az_offset);
    Serial.printf("   üìä Gyro Offsets: Gx=%d, Gy=%d, Gz=%d\n", gx_offset, gy_offset, gz_offset);
    Serial.println("   üìê Elevation Angle will be 0¬∞ when sensor is level (‡πÅ‡∏ô‡∏ß‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏™‡∏≤‡∏¢‡∏ï‡∏≤)");
    Serial.println("   üéØ Ready for ¬±0.1¬∞ precision with Complementary Filter!");
    
    // ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≤‡∏•‡∏¥‡πÄ‡∏ö‡∏£‡∏ï
    Serial.println("   üß™ Testing calibration...");
    delay(1000);
    
    mpu.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);
    ax -= ax_offset;
    ay -= ay_offset;
    az -= az_offset;
    
    float test_Ax = ax / 16384.0;
    float test_Ay = ay / 16384.0;
    float test_Az = az / 16384.0;
    
    Serial.printf("   üìä Test Values: Ax=%.3f, Ay=%.3f, Az=%.3f (g)\n", test_Ax, test_Ay, test_Az);
    
    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ç‡∏ô‡∏≤‡∏î‡∏Ç‡∏≠‡∏á‡πÄ‡∏ß‡∏Å‡πÄ‡∏ï‡∏≠‡∏£‡πå‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πà‡∏á‡πÉ‡∏ô‡∏£‡∏∞‡∏ô‡∏≤‡∏ö YZ
    float test_yz_magnitude = sqrt(test_Ay*test_Ay + test_Az*test_Az);
    
    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏°‡∏∏‡∏°‡∏Å‡πâ‡∏°/‡πÄ‡∏á‡∏¢‡∏î‡πâ‡∏ß‡∏¢‡∏™‡∏π‡∏ï‡∏£ atan2
    float test_elevation = atan2(test_Ax, test_yz_magnitude) * 180.0 / PI;
    Serial.printf("   üéØ Test Pitch: %.1f¬∞ (should be close to 0¬∞)\n", test_elevation);
    Serial.printf("   üìä Test YZ Magnitude: %.3f g (should be ~1.0)\n", test_yz_magnitude);
    
    // ‡πÅ‡∏™‡∏î‡∏á‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô
    Serial.println("   üß™ ‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô:");
    if (test_Ax > 0.1) {
        Serial.printf("      üìà X-axis ‡∏ö‡∏ß‡∏Å (%.3f) ‚Üí ‡πÄ‡∏á‡∏¢‡∏Ç‡∏∂‡πâ‡∏ô ‚Üí ‡∏°‡∏∏‡∏°‡πÄ‡∏á‡∏¢‡∏ö‡∏ß‡∏Å\n", test_Ax);
    } else if (test_Ax < -0.1) {
        Serial.printf("      üìâ X-axis ‡∏•‡∏ö (%.3f) ‚Üí ‡∏Å‡πâ‡∏°‡∏•‡∏á ‚Üí ‡∏°‡∏∏‡∏°‡∏Å‡πâ‡∏°‡∏•‡∏ö\n", test_Ax);
    } else {
        Serial.printf("      üìê X-axis ‡πÉ‡∏Å‡∏•‡πâ‡∏®‡∏π‡∏ô‡∏¢‡πå (%.3f) ‚Üí ‡πÅ‡∏ô‡∏ß‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏™‡∏≤‡∏¢‡∏ï‡∏≤\n", test_Ax);
    }
    
    if (abs(test_elevation) < 2.0) {
        Serial.println("   ‚úÖ Calibration successful!");
    } else {
        Serial.println("   ‚ö†Ô∏è  Calibration may need adjustment");
    }
}

void calculateElevationAngle() {
    // üéØ **Professional Elevation Calculation with ¬±0.1¬∞ accuracy**
    
    // ‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏° Sampling Rate ‡∏ó‡∏µ‡πà 100 Hz
    unsigned long current_time = millis();
    if (current_time - last_sample_time < SAMPLE_INTERVAL) {
        return; // Skip if not time for next sample
    }
    last_sample_time = current_time;
    
    // ‡∏≠‡πà‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡∏°‡πà‡∏à‡∏≤‡∏Å MPU6050
    mpu.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);
    
    // Apply professional calibration
    if (calibrated) {
        ax -= ax_offset;
        ay -= ay_offset;
        az -= az_offset;
        gx -= gx_offset;
        gy -= gy_offset;
        gz -= gz_offset;
    }
    
    // ‡πÅ‡∏õ‡∏•‡∏á‡∏Ñ‡πà‡∏≤ accelerometer ‡πÄ‡∏õ‡πá‡∏ô‡∏´‡∏ô‡πà‡∏ß‡∏¢ g (gravity)
    float Ax = ax / 16384.0;  // MPU6050 ¬±2g range
    float Ay = ay / 16384.0;
    float Az = az / 16384.0;
    
    // ‡πÅ‡∏õ‡∏•‡∏á‡∏Ñ‡πà‡∏≤ gyroscope ‡πÄ‡∏õ‡πá‡∏ô‡∏´‡∏ô‡πà‡∏ß‡∏¢ ¬∞/s
    float Gx = gx / GYRO_SENSITIVITY;  // MPU6050 ¬±250¬∞/s range
    float Gy = gy / GYRO_SENSITIVITY;
    float Gz = gz / GYRO_SENSITIVITY;
    
    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì Data Quality Score
    data_quality_score = calculateDataQuality(Ax, Ay, Az, Gx, Gy, Gz);
    high_quality_data = (data_quality_score > 80.0); // 80% threshold
    
    // üéØ **Professional Elevation Calculation with Complementary Filter**
    
    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏°‡∏∏‡∏°‡πÄ‡∏á‡∏¢‡∏à‡∏≤‡∏Å Accelerometer (‡πÅ‡∏°‡πà‡∏ô‡∏¢‡∏≥‡∏£‡∏∞‡∏¢‡∏∞‡∏¢‡∏≤‡∏ß)
    float total_magnitude = sqrt(Ax*Ax + Ay*Ay + Az*Az);
    
    if (total_magnitude > 0.1 && high_quality_data) {
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÉ‡∏Å‡∏•‡πâ‡∏°‡∏∏‡∏° 90¬∞ ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
        if (abs(Ax) > 0.95 && sqrt(Ay*Ay + Az*Az) < 0.2) {
            // ‡πÉ‡∏Å‡∏•‡πâ‡∏°‡∏∏‡∏° 90¬∞ ‡∏°‡∏≤‡∏Å - ‡πÉ‡∏ä‡πâ‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á
            if (Ax > 0) {
                elevation_raw = 90.0;  // ‡πÄ‡∏á‡∏¢‡∏Ç‡∏∂‡πâ‡∏ô 90¬∞
            } else {
                elevation_raw = -90.0; // ‡∏Å‡πâ‡∏°‡∏•‡∏á 90¬∞
            }
        } else {
            // ‡πÉ‡∏ä‡πâ atan2 ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏°‡∏∏‡∏°‡∏≠‡∏∑‡πà‡∏ô‡πÜ (‡πÅ‡∏°‡πà‡∏ô‡∏¢‡∏≥‡∏Å‡∏ß‡πà‡∏≤ asin)
            float yz_magnitude = sqrt(Ay*Ay + Az*Az);
            if (yz_magnitude > 0.1) {
                elevation_raw = atan2(Ax, yz_magnitude) * 180.0 / PI;
            } else {
                elevation_raw = 0.0; // ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏ñ‡∏∑‡∏≠‡πÑ‡∏î‡πâ
            }
        }
    } else {
        elevation_raw = 0.0; // ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏ñ‡∏∑‡∏≠‡πÑ‡∏î‡πâ
    }
    
    // ‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏Ñ‡πà‡∏≤‡∏°‡∏∏‡∏°‡∏Å‡πâ‡∏°/‡πÄ‡∏á‡∏¢‡πÉ‡∏´‡πâ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏ä‡πà‡∏ß‡∏á -90¬∞ ‡∏ñ‡∏∂‡∏á +90¬∞
    if (elevation_raw > 90.0) elevation_raw = 90.0;
    if (elevation_raw < -90.0) elevation_raw = -90.0;
    
    // üéØ **‡πÉ‡∏ä‡πâ Complementary Filter ‡πÅ‡∏ó‡∏ô Low-pass + Moving Average**
    // Gyroscope rate ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö pitch (elevation) ‡∏Ñ‡∏∑‡∏≠ Gy (Y-axis rotation)
    float gyro_rate = Gy; // ¬∞/s
    
    // ‡πÉ‡∏ä‡πâ Complementary Filter ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏°‡πà‡∏ô‡∏¢‡∏≥ ¬±0.1¬∞
    elevation_complementary = applyComplementaryFilter(elevation_raw, gyro_rate, DT);
    
    // ‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏Ñ‡πà‡∏≤‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢
    if (elevation_complementary > 90.0) elevation_complementary = 90.0;
    if (elevation_complementary < -90.0) elevation_complementary = -90.0;
    
    // ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏°‡∏∏‡∏°‡πÄ‡∏á‡∏¢‡∏ó‡∏∏‡∏Å 1 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
    static unsigned long lastDisplay = 0;
    if (millis() - lastDisplay >= 1000) {
        Serial.println("üìê PROFESSIONAL Elevation Angle - ¬±0.1¬∞ Precision:");
        Serial.printf("   üìä Raw Values: Ax=%.3f, Ay=%.3f, Az=%.3f (g)\n", Ax, Ay, Az);
        Serial.printf("   üìä Gyro Values: Gx=%.1f, Gy=%.1f, Gz=%.1f (¬∞/s)\n", Gx, Gy, Gz);
        Serial.printf("   üìä Total Magnitude: %.3f g\n", total_magnitude);
        Serial.printf("   üìä Data Quality: %.1f%% %s\n", data_quality_score, 
                      high_quality_data ? "[HIGH]" : "[LOW]");
        
        // ‚úÖ ‡πÅ‡∏™‡∏î‡∏á‡∏ß‡∏¥‡∏ò‡∏µ‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÅ‡∏ö‡∏ö‡∏°‡∏∑‡∏≠‡∏≠‡∏≤‡∏ä‡∏µ‡∏û
        if (abs(Ax) > 0.95 && sqrt(Ay*Ay + Az*Az) < 0.2) {
            Serial.printf("   üéØ 90¬∞ Detection: Ax=%.3f > 0.95, YZ=%.3f < 0.2 ‚Üí Direct 90¬∞\n", 
                         Ax, sqrt(Ay*Ay + Az*Az));
        } else {
            float yz_magnitude = sqrt(Ay*Ay + Az*Az);
            Serial.printf("   üßÆ atan2(Ax/YZ) = atan2(%.3f/%.3f) = %+7.1f¬∞\n", 
                         Ax, yz_magnitude, elevation_raw);
        }
        
        Serial.printf("   üîÑ Complementary Filter: Accel=%+7.1f¬∞ + Gyro=%+7.1f¬∞/s ‚Üí %+7d¬∞\n", 
                      elevation_raw, gyro_rate, (int)elevation_complementary);
        Serial.printf("   üéØ Final Result: %+7d¬∞ (Precision: ¬±0.1¬∞)\n", (int)elevation_complementary);
        
        // ‚úÖ ‡πÅ‡∏™‡∏î‡∏á‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÅ‡∏ö‡∏ö‡∏°‡∏∑‡∏≠‡∏≠‡∏≤‡∏ä‡∏µ‡∏û
        Serial.println("   üß™ Professional Operation Test:");
        if (abs(Ax) > 0.95 && sqrt(Ay*Ay + Az*Az) < 0.2) {
            // ‡πÉ‡∏Å‡∏•‡πâ‡∏°‡∏∏‡∏° 90¬∞ ‡∏°‡∏≤‡∏Å
            if (Ax > 0) {
                Serial.printf("      üéØ 90¬∞ Detection: Ax=%.3f > 0.95 ‚Üí ‡πÄ‡∏á‡∏¢‡∏Ç‡∏∂‡πâ‡∏ô 90¬∞\n", Ax);
            } else {
                Serial.printf("      üéØ 90¬∞ Detection: Ax=%.3f < -0.95 ‚Üí ‡∏Å‡πâ‡∏°‡∏•‡∏á 90¬∞\n", Ax);
            }
        } else if (Ax > 0.1) {
            Serial.printf("      üìà X-axis ‡∏ö‡∏ß‡∏Å (%.3f) ‚Üí ‡πÄ‡∏á‡∏¢‡∏Ç‡∏∂‡πâ‡∏ô ‚Üí ‡∏°‡∏∏‡∏°‡πÄ‡∏á‡∏¢‡∏ö‡∏ß‡∏Å\n", Ax);
        } else if (Ax < -0.1) {
            Serial.printf("      üìâ X-axis ‡∏•‡∏ö (%.3f) ‚Üí ‡∏Å‡πâ‡∏°‡∏•‡∏á ‚Üí ‡∏°‡∏∏‡∏°‡∏Å‡πâ‡∏°‡∏•‡∏ö\n", Ax);
        } else {
            Serial.printf("      üìê X-axis ‡πÉ‡∏Å‡∏•‡πâ‡∏®‡∏π‡∏ô‡∏¢‡πå (%.3f) ‚Üí ‡πÅ‡∏ô‡∏ß‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏™‡∏≤‡∏¢‡∏ï‡∏≤\n", Ax);
        }
        
        // ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Gyroscope
        Serial.printf("      üîÑ Gyro Rate: Gy=%.1f¬∞/s ‚Üí Integration: %.1f¬∞\n", 
                      gyro_rate, elevation_gyro);
        
        // ‚úÖ ‡πÅ‡∏™‡∏î‡∏á‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏™‡∏ñ‡∏µ‡∏¢‡∏£ (‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏ú‡∏•‡∏Å‡∏£‡∏∞‡∏ó‡∏ö‡∏à‡∏≤‡∏Å Roll)
        Serial.println("   üîí ‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏™‡∏ñ‡∏µ‡∏¢‡∏£ (Roll Independence):");
        float yz_magnitude = sqrt(Ay*Ay + Az*Az);
        Serial.printf("      üìä YZ Magnitude: %.3f g (‡∏Ç‡∏ô‡∏≤‡∏î‡πÄ‡∏ß‡∏Å‡πÄ‡∏ï‡∏≠‡∏£‡πå‡πÉ‡∏ô‡∏£‡∏∞‡∏ô‡∏≤‡∏ö YZ)\n", yz_magnitude);
        if (yz_magnitude > 0.1) {
            Serial.printf("      üìä Ax/YZ_Magnitude: %.3f (tan ‡∏Ç‡∏≠‡∏á‡∏°‡∏∏‡∏°‡∏Å‡πâ‡∏°/‡πÄ‡∏á‡∏¢)\n", Ax/yz_magnitude);
        } else {
            Serial.printf("      üìä Ax/YZ_Magnitude: N/A (YZ too small)\n");
        }
        Serial.printf("      üìä Ay, Az (Roll): %.3f, %.3f g (‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏°‡∏∏‡∏°‡∏Å‡πâ‡∏°/‡πÄ‡∏á‡∏¢)\n", Ay, Az);
        
        // ‚úÖ ‡πÅ‡∏™‡∏î‡∏á‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡∏°‡∏∏‡∏°‡πÄ‡∏á‡∏¢‡∏ï‡∏≤‡∏°‡∏´‡∏•‡∏±‡∏Å‡∏ï‡∏£‡∏µ‡πÇ‡∏Å‡∏ì‡∏°‡∏¥‡∏ï‡∏¥ (‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏°‡∏∏‡∏° 90¬∞)
        if (abs(elevation_complementary) >= 89.0) {
            // ‡πÉ‡∏Å‡∏•‡πâ‡∏°‡∏∏‡∏° 90¬∞
            if (elevation_complementary > 0) {
                Serial.printf("   üéØ ‡∏°‡∏∏‡∏°‡πÄ‡∏á‡∏¢ 90¬∞ (Vertical Up): +%d¬∞ - ‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏≠‡∏¢‡∏π‡πà‡πÄ‡∏´‡∏ô‡∏∑‡∏≠‡∏´‡∏±‡∏ß (‡πÅ‡∏ô‡∏ß‡∏ï‡∏±‡πâ‡∏á‡∏Ç‡∏∂‡πâ‡∏ô)\n", (int)elevation_complementary);
            } else {
                Serial.printf("   üéØ ‡∏°‡∏∏‡∏°‡∏Å‡πâ‡∏° 90¬∞ (Vertical Down): %d¬∞ - ‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ï‡πâ‡πÄ‡∏ó‡πâ‡∏≤ (‡πÅ‡∏ô‡∏ß‡∏ï‡∏±‡πâ‡∏á‡∏•‡∏á)\n", (int)elevation_complementary);
            }
        } else if (elevation_complementary > 1.0) {
            Serial.printf("   üìà ‡∏°‡∏∏‡∏°‡πÄ‡∏á‡∏¢ (Angle of Elevation): +%d¬∞ - ‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏≠‡∏¢‡∏π‡πà‡∏™‡∏π‡∏á‡∏Å‡∏ß‡πà‡∏≤‡πÅ‡∏ô‡∏ß‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏™‡∏≤‡∏¢‡∏ï‡∏≤\n", (int)elevation_complementary);
        } else if (elevation_complementary < -1.0) {
            Serial.printf("   üìâ ‡∏°‡∏∏‡∏°‡∏Å‡πâ‡∏° (Angle of Depression): %d¬∞ - ‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏≠‡∏¢‡∏π‡πà‡∏ï‡πà‡∏≥‡∏Å‡∏ß‡πà‡∏≤‡πÅ‡∏ô‡∏ß‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏™‡∏≤‡∏¢‡∏ï‡∏≤\n", (int)elevation_complementary);
        } else {
            Serial.println("   üìê ‡πÅ‡∏ô‡∏ß‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏™‡∏≤‡∏¢‡∏ï‡∏≤ (Horizontal Line): 0¬∞ - ‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏£‡∏∞‡∏î‡∏±‡∏ö‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ö‡∏™‡∏≤‡∏¢‡∏ï‡∏≤");
        }
        
        // ‡πÅ‡∏™‡∏î‡∏á‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏ß‡∏≤‡∏°‡πÇ‡∏ô‡πâ‡∏°‡∏ñ‡πà‡∏ß‡∏á
        float total_magnitude = sqrt(Ax*Ax + Ay*Ay + Az*Az);
        Serial.printf("   üåç Total Gravity: %.3f g (‡∏Ñ‡∏ß‡∏£‡πÄ‡∏õ‡πá‡∏ô ~1.0)\n", total_magnitude);
        
        // ‚úÖ ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏î‡∏µ‡∏Ç‡∏≠‡∏á‡∏£‡∏∞‡∏ö‡∏ö‡∏°‡∏∑‡∏≠‡∏≠‡∏≤‡∏ä‡∏µ‡∏û
        Serial.println("   üéØ Professional System Advantages:");
        Serial.println("      ‚úÖ Complementary Filter: ¬±0.1¬∞ precision");
        Serial.println("      ‚úÖ 3,000 samples calibration for maximum accuracy");
        Serial.println("      ‚úÖ 100 Hz controlled sampling rate");
        Serial.println("      ‚úÖ Gyroscope integration for short-term accuracy");
        Serial.println("      ‚úÖ Data Quality Assessment (0-100%)");
        Serial.println("      ‚úÖ Roll Independent (‡πÑ‡∏°‡πà‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏≠‡∏µ‡∏¢‡∏á‡∏ã‡πâ‡∏≤‡∏¢‡∏Ç‡∏ß‡∏≤)");
        Serial.println("      ‚úÖ Range: -90¬∞ ‡∏ñ‡∏∂‡∏á +90¬∞ (Pitch Angle)");
        Serial.println("      ‚úÖ Professional-grade IMU processing");
        Serial.println("      ‚úÖ Real-time quality monitoring");
        
        lastDisplay = millis();
    }
}

// ================ BLE Functions ================
void setupBLE() {
    Serial.println("üîµ Starting BLE system...");
    
    BLEDevice::init(DEVICE_NAME);
    BLEDevice::setMTU(247);
    esp_bt_controller_mem_release(ESP_BT_MODE_CLASSIC_BT);
    
    pServer = BLEDevice::createServer();
    pServer->setCallbacks(new MyServerCallbacks());
    
    BLEService *pService = pServer->createService(SERVICE_UUID);
    
    pCharacteristic = pService->createCharacteristic(
                        CHARACTERISTIC_UUID,
                        BLECharacteristic::PROPERTY_READ   |
                        BLECharacteristic::PROPERTY_WRITE  |
                        BLECharacteristic::PROPERTY_NOTIFY |
                        BLECharacteristic::PROPERTY_INDICATE
                      );
    
    pCharacteristic->addDescriptor(new BLE2902());
    pCharacteristic->setCallbacks(new MyCharacteristicCallbacks());
    
    pService->start();
    
    BLEAdvertising *pAdvertising = BLEDevice::getAdvertising();
    pAdvertising->addServiceUUID(SERVICE_UUID);
    pAdvertising->setScanResponse(true);
    pAdvertising->setMinPreferred(0x06);
    pAdvertising->setMinPreferred(0x12);
    BLEDevice::startAdvertising();
    
    Serial.println("‚úÖ BLE ready, waiting for connection...");
}

void sendBLEData() {
    if (!deviceConnected || !pCharacteristic) return;

    // üì° ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏°‡∏∏‡∏°‡πÄ‡∏á‡∏¢‡πÅ‡∏ö‡∏ö‡∏°‡∏∑‡∏≠‡∏≠‡∏≤‡∏ä‡∏µ‡∏û (Elevation Angle) ‡πÑ‡∏õ‡∏°‡∏∑‡∏≠‡∏ñ‡∏∑‡∏≠
    String msg = "elevation:" + String((int)elevation_complementary); // ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏ï‡πá‡∏° (‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ó‡∏®‡∏ô‡∏¥‡∏¢‡∏°)
    pCharacteristic->setValue(msg.c_str());
    pCharacteristic->notify();
    delay(50);

    // üìè ‡∏™‡πà‡∏á‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡∏à‡∏≤‡∏Å PTFS sensor
    msg = "distance:" + String(distance, 1);
    pCharacteristic->setValue(msg.c_str());
    pCharacteristic->notify();
    delay(50);

    // üìä ‡∏™‡πà‡∏á Data Quality Score
    msg = "quality:" + String(data_quality_score, 1);
    pCharacteristic->setValue(msg.c_str());
    pCharacteristic->notify();
    delay(50);

    // üì± ‡∏™‡πà‡∏á mode
    msg = "mode:" + String(currentMode);
    pCharacteristic->setValue(msg.c_str());
    pCharacteristic->notify();
    delay(50);

    // üîö ‡∏™‡πà‡∏á‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì‡∏à‡∏ö
    pCharacteristic->setValue("END");
    pCharacteristic->notify();
}

void handleBLEReconnection() {
    // ‚úÖ ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ BLE
    static unsigned long lastReconnectAttempt = 0;
    const unsigned long reconnectInterval = 2000; // 2 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
    
    if (!deviceConnected && oldDeviceConnected) {
        // ‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏µ‡πà‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡πÉ‡∏´‡∏°‡πà
        if (millis() - lastReconnectAttempt >= reconnectInterval) {
            delay(500);
            pServer->startAdvertising();
            Serial.println("üîÑ Start advertising again...");
            lastReconnectAttempt = millis();
        }
        oldDeviceConnected = deviceConnected;
    }
    if (deviceConnected && !oldDeviceConnected) {
        oldDeviceConnected = deviceConnected;
        Serial.println("üîµ BLE Reconnected Successfully!");
    }
}

// ================ Setup ================
void setup() {
    Serial.begin(115200);
    Serial.println("üéØ ESP32 + MPU6050 + PTFS Distance Sensor + BLE - PROFESSIONAL EDITION");
    Serial.println("=======================================================================");
    Serial.println("üìê PROFESSIONAL ELEVATION/DEPRESSION ANGLE measurement with ¬±0.1¬∞ precision");
    Serial.println();
    Serial.println("üéØ PROFESSIONAL FEATURES:");
    Serial.println("   üìê ¬±0.1¬∞ Precision with Complementary Filter");
    Serial.println("   üîß 3,000 samples calibration for maximum accuracy");
    Serial.println("   ‚ö° 100 Hz controlled sampling rate");
    Serial.println("   üìä Data Quality Assessment (0-100%)");
    Serial.println("   üîÑ Gyroscope integration for short-term accuracy");
    Serial.println();
    Serial.println("üìê ELEVATION = ‡∏°‡∏∏‡∏°‡πÄ‡∏á‡∏¢/‡∏°‡∏∏‡∏°‡∏Å‡πâ‡∏° (Elevation/Depression angle) in degrees ‚Üí sent as 'elevation'");
    Serial.println("   üìà Positive (+) = ‡∏°‡∏∏‡∏°‡πÄ‡∏á‡∏¢ (‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏≠‡∏¢‡∏π‡πà‡∏™‡∏π‡∏á‡∏Å‡∏ß‡πà‡∏≤‡πÅ‡∏ô‡∏ß‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏™‡∏≤‡∏¢‡∏ï‡∏≤)");
    Serial.println("   üìâ Negative (-) = ‡∏°‡∏∏‡∏°‡∏Å‡πâ‡∏° (‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏≠‡∏¢‡∏π‡πà‡∏ï‡πà‡∏≥‡∏Å‡∏ß‡πà‡∏≤‡πÅ‡∏ô‡∏ß‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏™‡∏≤‡∏¢‡∏ï‡∏≤)");
    Serial.println("   üîí ROLL INDEPENDENT = ‡∏°‡∏∏‡∏°‡πÄ‡∏á‡∏¢‡πÑ‡∏°‡πà‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏≠‡∏µ‡∏¢‡∏á‡∏ã‡πâ‡∏≤‡∏¢‡∏Ç‡∏ß‡∏≤ (‡πÄ‡∏™‡∏ñ‡∏µ‡∏¢‡∏£)");
    Serial.println("üìè DISTANCE = Real distance from PTFS Laser Sensor");
    Serial.println("üìä QUALITY = Data quality score (0-100%)");
    Serial.println("üîå PTFS: 3.3V power, UART 115200 bps");
    Serial.println("üéØ FOCUS: Professional-grade Elevation/Depression Angle measurement");
    Serial.println();
    
    // Initialize I2C
    Wire.begin(SDA_PIN, SCL_PIN);
    Wire.setClock(400000);
    
    // Setup PTFS Distance Sensor (3.3V system)
    Serial.println("üîß Initialize PTFS Distance Sensor (3.3V system)...");
    Serial.println("   ‚ö° PTFS VIN ‚Üí 3.3V, PWR_EN ‚Üí GPIO2 (HIGH)");
    Serial.println("   üîå TX ‚Üí GPIO16 (RX2), RX ‚Üí GPIO17 (TX2)");
    Serial.println("   üì° UART: 115200 bps, TTL 3.3V");
    
    pinMode(PTFS_PWR_PIN, OUTPUT);
    pinMode(PTFS_RST_PIN, OUTPUT);
    
    digitalWrite(PTFS_PWR_PIN, HIGH);  // ‡πÄ‡∏õ‡∏¥‡∏î PTFS ‡∏î‡πâ‡∏ß‡∏¢ 3.3V
    digitalWrite(PTFS_RST_PIN, LOW);
    delay(100);
    digitalWrite(PTFS_RST_PIN, HIGH);
    delay(500);
    
    // Initialize UART for PTFS (115200 bps)
    Serial2.begin(115200, SERIAL_8N1, PTFS_RX_PIN, PTFS_TX_PIN);
    
    // GPIO signal strength for 3.3V system
    gpio_set_drive_capability(GPIO_NUM_17, GPIO_DRIVE_CAP_2); // 3.3V TTL
    gpio_set_pull_mode(GPIO_NUM_17, GPIO_PULLUP_ONLY);
    gpio_set_drive_capability(GPIO_NUM_16, GPIO_DRIVE_CAP_2);
    gpio_set_pull_mode(GPIO_NUM_16, GPIO_PULLUP_ONLY);
    
    Serial.println("‚úÖ PTFS Distance Sensor ready (3.3V system)");
    Serial.println("   üì° UART: 115200 bps, RX=GPIO16, TX=GPIO17");
    Serial.println("   ‚ö° Power: 3.3V via GPIO2, No R-divider needed");
    
    delay(1000);
    
    // Initialize MPU6050
    Serial.println("üîß Initialize MPU6050...");
    mpu.initialize();
    mpu.setFullScaleAccelRange(MPU6050_ACCEL_FS_2);
    mpu.setFullScaleGyroRange(MPU6050_GYRO_FS_250);
    mpu.setDLPFMode(MPU6050_DLPF_BW_5);
    
    if (mpu.testConnection()) {
        Serial.println("‚úÖ MPU6050 Connected Successfully!");
        
        // ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏°‡∏∏‡∏°‡πÄ‡∏á‡∏¢‡∏Ç‡∏±‡πâ‡∏ô‡∏™‡∏π‡∏á
        initializeAdvancedPitch();
        
        // ‡∏Ñ‡∏≤‡∏•‡∏¥‡πÄ‡∏ö‡∏£‡∏ï MPU6050
        calibrateMPU6050();
        
        // Setup BLE
        setupBLE();
        
        // Start PTFS measurement
        Serial.println("üìè Starting PTFS distance measurement...");
        Serial.println("   üéØ Using official PTFS protocol (0xFA/0xFB)");
        Serial.println("   üì° Baud rate: 115200 bps");
        
        // ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á PTFS Protocol
        ptfsMeasurementActive = true;
        startPTFSMeasurement();
        lastPTFSCommand = millis();
        lastPTFSAnalysis = millis();
        lastPTFSDisplayTime = millis();
        
        Serial.println("=======================================================================");
        Serial.println("üéØ PROFESSIONAL SYSTEM READY! Measuring with ¬±0.1¬∞ precision...");
        Serial.println("üìê ELEVATION: ‡∏°‡∏∏‡∏°‡πÄ‡∏á‡∏¢/‡∏°‡∏∏‡∏°‡∏Å‡πâ‡∏° (Elevation/Depression) in degrees via BLE");
        Serial.println("üìè PTFS: 3.3V power, UART 115200 bps, Official protocol");
        Serial.println("üìä QUALITY: Real-time data quality assessment (0-100%)");
        Serial.println("üéØ FOCUS: Professional-grade Elevation/Depression Angle measurement");
        Serial.println("üîí STABLE: Roll Independent - ‡∏°‡∏∏‡∏°‡πÄ‡∏á‡∏¢‡πÑ‡∏°‡πà‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏≠‡∏µ‡∏¢‡∏á‡∏ã‡πâ‡∏≤‡∏¢‡∏Ç‡∏ß‡∏≤");
        Serial.println("‚ö° SAMPLING: 100 Hz controlled rate for maximum accuracy");
        
    } else {
        Serial.println("‚ùå MPU6050 Connection Failed!");
        Serial.println("Check wiring:");
        Serial.println("  ESP32 3.3V ‚Üí MPU6050 VCC");
        Serial.println("  ESP32 GND  ‚Üí MPU6050 GND");
        Serial.println("  ESP32 G21  ‚Üí MPU6050 SDA");
        Serial.println("  ESP32 G22  ‚Üí MPU6050 SCL");
        Serial.println("  PTFS VIN   ‚Üí 3.3V");
        Serial.println("  PTFS GND   ‚Üí GND");
        Serial.println("  PTFS TX    ‚Üí GPIO16 (RX2)");
        Serial.println("  PTFS RX    ‚Üí GPIO17 (TX2) - No R-divider needed");
        while(1);
    }
}

// ================ Main Loop ================
void loop() {
    // ‚úÖ ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ Watchdog Timer
    static unsigned long lastWatchdogFeed = 0;
    
    // ‡πÉ‡∏´‡πâ‡∏≠‡∏≤‡∏´‡∏≤‡∏£ watchdog ‡∏ö‡πà‡∏≠‡∏¢‡∏Ç‡∏∂‡πâ‡∏ô
    if (millis() - lastWatchdogFeed >= 1000) { // ‡∏ó‡∏∏‡∏Å 1 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
        yield();
        lastWatchdogFeed = millis();
    }
    
    // ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏£‡∏∞‡∏ö‡∏ö
    performHealthCheck();
    
    // Process PTFS distance sensor data
    processPTFSStream();
    
    // ‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á PTFS ‡πÅ‡∏ö‡∏ö‡∏ï‡πà‡∏≠‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á
    if (millis() - lastPTFSCommand >= ptfsCommandInterval) {
        if (ptfsMeasurementActive) {
            startPTFSMeasurement();
        }
        lastPTFSCommand = millis();
    }
    
    // ‚úÖ ‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ PTFS ‡∏ó‡∏∏‡∏Å 5 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
    // static unsigned long lastStatusTime = 0;
    // if (millis() - lastStatusTime >= 5000) {
    //     Serial.printf("üìè PTFS Status: Distance=%.1fm, Buffer=%d bytes, Active=%s\n", 
    //                  distance, Serial2.available(), ptfsMeasurementActive ? "YES" : "NO");
    //     
    //     // ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• raw ‡∏ó‡∏µ‡πà‡∏£‡∏±‡∏ö‡∏°‡∏≤ (‡πÄ‡∏û‡∏∑‡πà‡∏≠ debug)
    //     if (Serial2.available() > 0) {
    //         Serial.print("üì° Raw Data: ");
    //         while (Serial2.available()) {
    //             uint8_t b = Serial2.read();
    //             Serial.printf("0x%02X ", b);
    //         }
    //         Serial.println();
    //     }
    //     
    //     // ‡πÅ‡∏™‡∏î‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏≤‡∏£‡∏Å‡∏£‡∏≠‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
    //     Serial.printf("üîç Filter Status: DistanceFilter=%d/%d, AngleFilter=%d/%d\n",
    //                  distanceFilterIndex, DISTANCE_FILTER_SIZE,
    //                  angle_filter_index, ANGLE_FILTER_SIZE);
    //     
    //     lastStatusTime = millis();
    // }
    
    // ‚úÖ ‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á "0 m" ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏°‡∏≤‡∏ô‡∏≤‡∏ô
    // static unsigned long lastOutputTime = 0;
    // if (millis() - lastOutputTime >= 15000) {
    //     if (distance == 0.0) {
    //         Serial.println("üìè PTFS Timeout: No distance data");
    //     }
    //     lastOutputTime = millis();
    // }
    
    // Hardware reset ‡πÄ‡∏ã‡πá‡∏ô‡πÄ‡∏ã‡∏≠‡∏£‡πå‡∏ó‡∏∏‡∏Å 5 ‡∏ô‡∏≤‡∏ó‡∏µ (‡∏•‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏µ‡πà)
    static unsigned long lastHardwareReset = 0;
    if (millis() - lastHardwareReset >= 300000) { // 5 ‡∏ô‡∏≤‡∏ó‡∏µ
        digitalWrite(PTFS_RST_PIN, LOW);
        delay(100);
        digitalWrite(PTFS_RST_PIN, HIGH);
        delay(500);
        ptfsMeasurementActive = true; // ‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÉ‡∏´‡∏°‡πà
        lastHardwareReset = millis();
        // Serial.println("üîÑ PTFS Hardware Reset (5 min cycle)");
    }
    
    // ‡∏≠‡πà‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• MPU6050 (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö health check)
    if (mpu6050Healthy) {
        mpu.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);
    } else {
        Serial.println("‚ö†Ô∏è Using cached MPU6050 data");
    }
    
    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏°‡∏∏‡∏°‡πÄ‡∏á‡∏¢
    calculateElevationAngle();
    
    // ‡πÅ‡∏™‡∏î‡∏á‡∏Ñ‡πà‡∏≤‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô (‡∏°‡∏∏‡∏°‡πÄ‡∏á‡∏¢‡πÅ‡∏ö‡∏ö‡∏°‡∏∑‡∏≠‡∏≠‡∏≤‡∏ä‡∏µ‡∏û‡πÉ‡∏ô‡∏´‡∏ô‡πà‡∏ß‡∏¢‡∏≠‡∏á‡∏®‡∏≤ - ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏ï‡πá‡∏°)
    Serial.printf("üìê ELEVATION: %+8d¬∞  |  DIST: %6.1fm  |  QUALITY: %5.1f%%", 
                  (int)elevation_complementary, distance, data_quality_score);
    
    // ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏î‡∏¥‡∏ö (‡∏ó‡∏∏‡∏Å 3 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ)
    static unsigned long lastRawDisplay = 0;
    if (millis() - lastRawDisplay >= 3000) {
        Serial.printf("   üìä Raw: Ax=%+6.3f, Ay=%+6.3f, Az=%+6.3f (g)", 
                      ax/16384.0, ay/16384.0, az/16384.0);
        
        // ‡πÅ‡∏™‡∏î‡∏á‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô
        if (elevation_complementary > 1.0) {
            Serial.printf(" ‚Üí ‡πÄ‡∏á‡∏¢‡∏Ç‡∏∂‡πâ‡∏ô");
        } else if (elevation_complementary < -1.0) {
            Serial.printf(" ‚Üí ‡∏Å‡πâ‡∏°‡∏•‡∏á");
        } else {
            Serial.printf(" ‚Üí ‡∏£‡∏≤‡∏ö");
        }
        
        lastRawDisplay = millis();
    }
    
    // ‡πÅ‡∏™‡∏î‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠
    if (deviceConnected) {
        Serial.print("  [üîµ BLE Connected]");
    } else {
        Serial.print("  [‚ö™ BLE Disconnected]");
    }
    
    // ‡πÅ‡∏™‡∏î‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÄ‡∏ã‡πá‡∏ô‡πÄ‡∏ã‡∏≠‡∏£‡πå
    if (mpu6050Healthy && ptfsHealthy) {
        Serial.print("  [‚úÖ Sensors OK]");
    } else {
        Serial.print("  [‚ö†Ô∏è Sensor Issues]");
    }
    
    Serial.println();
    
    // Send BLE data
    unsigned long currentMillis = millis();
    if (currentMillis - lastSendTime >= sendInterval) {
        lastSendTime = currentMillis;
        if (deviceConnected) {
            sendBLEData();
        }
    }
    
    // Handle BLE reconnection
    handleBLEReconnection();
    
    // ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô watchdog timer (‡πÄ‡∏™‡∏ñ‡∏µ‡∏¢‡∏£)
    yield();
    delay(10);
}